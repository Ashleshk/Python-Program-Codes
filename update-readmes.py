#!/usr/bin/env python3

# This is free and unencumbered software released into the public
# domain.

# Anyone is free to copy, modify, publish, use, compile, sell, or
# distribute this software, either in source code form or as a
# compiled binary, for any purpose, commercial or non-commercial, and
# by any means.

# In jurisdictions that recognize copyright laws, the author or
# authors of this software dedicate any and all copyright interest in
# the software to the public domain. We make this dedication for the
# benefit of the public at large and to the detriment of our heirs
# and successors. We intend this dedication to be an overt act of
# relinquishment in perpetuity of all present and future rights to
# this software under copyright law.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# For more information, please refer to <http://unlicense.org>

"""Generate basics/README.md and advanced/README.md."""

import os
import posixpath

import common


BEGINNING = """\
[comment]: # (This file is automatically generated. Don't edit this)
[comment]: # (file manually, run update-readmes.py instead.)

"""


def get_contents():
    """Read descriptions and contents lists from README.

    Return a {chaptername: content} dictionary.
    """
    result = {} 
    current_section = None

    with open('README.md', 'r') as f:
        # move to where the content list starts
        while f.readline().strip() != "## List of contents":
            pass

        for line in f:
            if line.startswith('### '):
                # new section
                current_section = common.header_link(line.lstrip('#').strip())
                result[current_section] = line[2:]  # one # instead of 3
            elif line.startswith('## '):
                # end of content lists
                break
            elif current_section is not None:
                # we are currently in a section
                result[current_section] += line

    return result


def update_file(filename, content):
    """Make sure that a file contains the content.

    Return True if the file changed and False if it didn't.
    """
    try:
        with open(filename, 'r') as f:
            # ignore the end
            old_content = f.read().split('\n***\n')[0].rstrip()
        if old_content == content:
            print("Has correct content:", filename)
            return False
    except FileNotFoundError:
        # the file doesn't exist yet, we'll create it
        pass

    print("Writing new content:", filename)
    with open(filename, 'w') as f:
        print(content, file=f)
    return True


def main():
    something_changed = False
    for directory, content in sorted(get_contents().items()):
        if not os.path.exists(directory):
            # something else under the list of contents than a chapter
            # list, doesn't have a separate subdirectory
            print("Not a directory:", directory)
            continue

        # the links that point to the subdir must now point to the
        # current directory, so we fix that
        content = BEGINNING + content.replace(directory + '/', '').rstrip()
        path = os.path.join(directory, 'README.md')
        this_changed = update_file(path, content)
        something_changed = something_changed or this_changed

    if something_changed:
        print()
        print("Run update-ends.py now so the files will have correct ends.")


if __name__ == '__main__':
    main()
